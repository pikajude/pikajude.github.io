-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Tree representations of datatypes
--   
--   <tt>type-tree</tt> provides TH splices for generating tree
--   representations of the types contained in datatypes. This is useful
--   for, for example, generating class instances for a deeply nested
--   datatype.
@package type-tree
@version 0.1.0.0

module Language.Haskell.TypeTree.Datatype
data Binding
Bound :: Name -> Binding
Unbound :: Name -> Binding
class IsDatatype a
asDatatype :: IsDatatype a => a -> Q (Binding, [Type])
unwrap :: Type -> (Binding, [Type])
guess :: Name -> Binding
instance GHC.Classes.Eq Language.Haskell.TypeTree.Datatype.Binding
instance GHC.Classes.Ord Language.Haskell.TypeTree.Datatype.Binding
instance GHC.Show.Show Language.Haskell.TypeTree.Datatype.Binding
instance Language.Haskell.TypeTree.Datatype.IsDatatype Language.Haskell.TH.Syntax.Name
instance Language.Haskell.TypeTree.Datatype.IsDatatype Language.Haskell.TH.Lib.TypeQ

module Language.Haskell.TypeTree

-- | Build a "type tree" of the given datatype.
--   
--   Concrete types will appear in the tree as <a>ConL</a>. Unbound
--   variables will appear as <a>VarL</a>. If the datastructure is
--   recursive, occurrences of the node after the first will be wrapped in
--   <a>Recursive</a>.
ttReify :: IsDatatype t => t -> Q (Tree Leaf)

-- | <a>ttReify</a> with the provided options.
ttReifyOpts :: IsDatatype t => ReifyOpts -> t -> Q (Tree Leaf)

-- | Embed the produced tree as an expression.
ttLit :: IsDatatype t => t -> ExpQ

-- | <a>ttLit</a> with provided opts.
ttLitOpts :: IsDatatype t => ReifyOpts -> t -> ExpQ

-- | Produces a string literal representing a type tree. Useful for
--   debugging purposes.
ttDescribe :: IsDatatype t => t -> ExpQ

-- | <a>ttDescribe</a> with the given options.
ttDescribeOpts :: IsDatatype t => ReifyOpts -> t -> ExpQ

-- | Some type and its arguments, as representable in a graph.
type Key = (Name, [Type])

-- | Type constructor arity.
type Arity = Int

-- | <pre>
--   $(ttEdges ''Foo) :: [((<a>Name</a>, <a>Arity</a>), <a>Key</a>, [<a>Key</a>])]
--   </pre>
--   
--   <tt>$(ttEdges ''Foo)</tt> produces a list suitable for passing to
--   <a>graphFromEdges</a>.
ttEdges :: IsDatatype t => t -> ExpQ

-- | <pre>
--   $(ttConnComp ''Foo) :: [<a>SCC</a> (<a>Name</a>, <a>Arity</a>)]
--   </pre>
--   
--   <tt>$(ttConnComp ''Foo)</tt> produces a topologically sorted list of
--   the strongly connected components of the graph representing
--   <tt>Foo</tt>.
ttConnComp :: IsDatatype t => t -> ExpQ
data Leaf

-- | <tt>ConL (name, xs)</tt> is a field with type <tt>ConT name</tt>,
--   applied to types <tt>xs</tt>.
ConL :: (Name, [Type]) -> Leaf

-- | <tt>VarL (name, xs)</tt> is a field with type <tt>VarT name</tt>,
--   applied to types <tt>xs</tt>.
VarL :: (Name, [Type]) -> Leaf

-- | Recursive field.
Recursive :: Leaf -> Leaf
data ReifyOpts
ReifyOpts :: Bool -> Set Name -> ReifyOpts

-- | Descend into primitive type constructors?
[expandPrim] :: ReifyOpts -> Bool

-- | If a name in this set is encountered, stop descending.
[terminals] :: ReifyOpts -> Set Name

-- | Default reify options.
--   
--   <pre>
--   defaultOpts = <a>ReifyOpts</a>
--     { expandPrim = False
--     , terminals = mempty
--     }
--   </pre>
defaultOpts :: ReifyOpts
instance GHC.Show.Show Language.Haskell.TypeTree.ReifyEnv
